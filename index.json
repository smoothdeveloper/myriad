[{"uri":"https://moiraesoftware.github.io/myriad//index.html","title":"Myriad Overview","content":"\r\n# Myriad\r\n\r\nMyriad is a code generator, it can take an arbitrary file and uses it to produce actual F# code.  The file can be anything from a plain txt file to an F# file.  \r\n\r\nMyriad can be used via MSBuild as part of a your project file, or standalone from its CLI tool.\r\n\r\nThe idea behind Myriad is to un-complicate, as far as possible, the ability to generate code and do meta-programming in F#. By meta-programming in F# I mean generating actual F# types and constructs like discriminated unions and records, not just IL output or simple classes like type providers.\r\n\r\nMyriad is an evolution of the ideas I developed while working with F#'s type providers and other meta-programming functionality like quotations and AST manipulation. Myriad aims to make it easy to extend the compiler via Myriad plugins rather than modifying or adjusting Type Providers and other F# improvements that would take a long time to be developed and released.  \r\n\r\nThe idea is you write a Myriad plugin that works on a particular file type, this could be a fragment of AST input or a proto file etc.  The plugin is supplied the file name various helpers in the library make it easier to produce the AST output with the final form being source code that is built into your project.  The advantages of this are the compiler can optimise the generated code and tooling can operate effectively too as you can navigate the generated code as normal.\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/creating-a-generator.html","title":"Creating a Generator","content":"\r\n# Building a Generator from scratch  \r\n\r\n![Generator](/myriad/static/images/pexels-spacex-586024.jpg)\r\n\r\nIm sorry there is no step by step guide (Yet) you can use the following as reference until I get around to writing it:\r\n\r\n[Applied Metaprogramming with Myriad and Falanx](https://7sharp9.github.io/fsharp/2019-04-24-applied-metaprogramming-with-myriad/)  - This is a video I made for my YouTube chanell which covers some details on Myriad.  \r\n\r\n\r\n[Myriad Intro](https://7sharp9.github.io/fsharp/2019-11-06-myriad-intro/) - This is a blog post I wrote around the time of Applied Metaprogramming with Myriad and Falanx which has details of making a generator that produces a simple module:\r\n:\r\n\r\n```fsharp\r\nmodule example1 =\r\n    let fourtyTwo = 42\r\n```\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/du-extensions.html","title":"DU Extensions","content":"\r\nThe input file in this example `Library.fs` looks like this:\r\n\r\n```fsharp\r\nnamespace Example\r\nopen Myriad.Plugins\r\n\r\n[<Generator.DuCases \"dus\" >]\r\ntype Currency =\r\n| CAD\r\n| PLN\r\n| EUR\r\n| USD\r\n| Custom of string\r\n\r\n```\r\n\r\nAn attribute is used by the plugin so that the code generator plugin knows which parts of the input AST are to be used by the plugin.  If you had several records and you only wanted the fields plugin to operate on `Currency` then the attribute would be used like in the example about to only apply `Generator.DuCases` to `Currency`.  Note, if you wanted a plugin that just needs the whole input AST then there is no need to provide an input.  Myriad aims to be a library rather than a full framework that ties you to the mechanism used to input and generate code.\r\n\r\nTo control what namespace is used as well as supplying any other information to plugins a `myriad.toml` configuration file is used.  This is specified in the generator attribute, in the example above you can see the configuration section is `dus`  `[<Generator.DuCases \"dus\" >]`.  The corresponding `myriad.toml` file looks as follows:  \r\n\r\n```toml\r\n[dus]\r\nnamespace = \"TestDus\"\r\n```\r\n\r\nThe DuCases plugin uses only a single configuration key `namespace` to control the resulting namespace the DuCases are generated\r\n\r\nThe fields plugin in this example will generate the following code at prebuild time and compile the code into your assembly:\r\n```fsharp\r\n//------------------------------------------------------------------------------\r\n//        This code was generated by myriad.\r\n//        Changes to this file will be lost when the code is regenerated.\r\n//------------------------------------------------------------------------------\r\nnamespace rec TestDus\r\n\r\nmodule Currency =\r\n    open Input\r\n\r\n    let toString (x: Currency) =\r\n        match x with\r\n        | CAD -> \"CAD\"\r\n        | PLN -> \"PLN\"\r\n        | EUR -> \"EUR\"\r\n        | USD -> \"USD\"\r\n        | Custom _ -> \"Custom\"\r\n\r\n    let fromString (x: string) =\r\n        match x with\r\n        | \"CAD\" -> Some CAD\r\n        | \"PLN\" -> Some PLN\r\n        | \"EUR\" -> Some EUR\r\n        | \"USD\" -> Some USD\r\n        | _ -> None\r\n\r\n    let toTag (x: Currency) =\r\n        match x with\r\n        | CAD -> 0\r\n        | PLN -> 1\r\n        | EUR -> 2\r\n        | USD -> 3\r\n        | Custom _ -> 4\r\n\r\n    let isCAD (x: Currency) =\r\n        match x with\r\n        | CAD -> true\r\n        | _ -> false\r\n\r\n    let isPLN (x: Currency) =\r\n        match x with\r\n        | PLN -> true\r\n        | _ -> false\r\n\r\n    let isEUR (x: Currency) =\r\n        match x with\r\n        | EUR -> true\r\n        | _ -> false\r\n\r\n    let isUSD (x: Currency) =\r\n        match x with\r\n        | USD -> true\r\n        | _ -> false\r\n\r\n    let isCustom (x: Currency) =\r\n        match x with\r\n        | Custom _ -> true\r\n        | _ -> false\r\n```\r\n\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/lenses.html","title":"Lenses","content":"\r\n# Lenses\r\n\r\nMyriad can also generate [lenses](https://fsprojects.github.io/FSharpPlus/tutorial.html#Lens) for records and single-case discriminated unions.\r\nLens is a pair of a getter and a setter for one property of the type and allows, given the object, to get the value of the property or to update it creating a new object. The advantage of lenses is an ability to combine them to read or update nested fields of the object.\r\n\r\nTo create lenses for your type, first annotate the type for which you want lenses to be generated with `Generator.Lenses` attribute, note the \"lens\" parameter specifies which configuration key is used with the plugin, this is used to specify which namespace is generated via the `myriad.toml` configuration file:\r\n\r\n```fsharp\r\n[<Generator.Lenses(\"lens\")>]\r\ntype Record =\r\n    { one: int\r\n      two: string }\r\n```\r\n\r\nMyriad will generate the following code:\r\n\r\n```fsharp\r\nmodule RecordLenses =\r\n    let one = (fun (x: Test1) -> x.one), (fun (x: Test1) (value: int) -> { x with one = value })\r\n    let two = (fun (x: Test1) -> x.two), (fun (x: Test1) (value: string) -> { x with two = value })\r\n```\r\n\r\nOften lenses are defined as a single-case union around a pair of getter and setter. Myriad is also capable of adding the invocation of such DU's constructor.\r\n\r\nTo achieve this, add the type `Lens` to the `Generator.Lenses` attribute, specifying the name of the DU constructor: `[<Generator.Lenses(\"lens\", \"Lens\")>]`, and Myriad will generate this code:\r\n\r\n```fsharp\r\nmodule RecordLenses =\r\n    let one = Lens((fun (x: Test1) -> x.one), (fun (x: Test1) (value: int) -> { x with one = value }))\r\n    let two = Lens((fun (x: Test1) -> x.two), (fun (x: Test1) (value: string) -> { x with two = value }))\r\n```\r\n\r\nYou can provide the name of DU constructor in several ways:\r\n- As a string: `[<Generator.Lenses(\"lens\", \"Lens\")>]`;\r\n- Or as a type: `[<Generator.Lenses(\"lens\", typedefof<Lens<_, _>>)>]` or `[<Generator.Lenses(\"lens\", typeof<Lens<_, _>>)>]`.\r\n\r\nIf the `Lens` type is in different namespace/module than the type decorated with the attribute, provide the full name of the `Lens` constructor: `[<Generator.Lenses(\"Namespace.And.Module.Of.Lens\")>]`."},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/record-fields.html","title":"Record Extensions","content":"\r\nThe input file in this example `Library.fs` looks like this:\r\n\r\n```fsharp\r\nnamespace Example\r\nopen Myriad.Plugins\r\n\r\n[<Generator.Fields \"fields\">]\r\ntype Test1 = { one: int; two: string; three: float; four: float32 }\r\ntype Test2 = { one: Test1; two: string }\r\n```\r\n\r\nAn attribute is used by the fields plugin so that the code generator knows which parts of the input AST should be consumed by the plugin.  If you had several records and you only wanted the fields plugin to operate on `Test1` then the attribute would be used like in the example about to only apply `Generator.Fields` to the `Test1` record.  Note, if you wanted a plugin that just processes the whole input then there is no need to provide such an attribute.  Myriad aims to be a library rather than a full framework that ties you to the mechanism used to input and generate code, its up to you how you generate the code, Myriad just aims to help to make this as painless and flexible as possible.\r\n\r\nTo control what namespace is used as well as supplying any other information to plugins a `myriad.toml` configuration file is used.  This is specified in the generator attribute, in the example above you can see the configuration section is `fields`  `[<Generator.Fields \"fields\">]`.  The corresponding `myriad.toml` file looks as follows:  \r\n\r\n```toml\r\n[fields]\r\nnamespace = \"TestFields\"\r\n```\r\n\r\nThe fields plugin uses only a single configuration key `namespace` to control the resulting namespace the record helpers are generated\r\n\r\n\r\nThe fields plugin in this example will generate the following code at prebuild and compile the code into your assembly:\r\n```fsharp\r\n//------------------------------------------------------------------------------\r\n//        This code was generated by myriad.\r\n//        Changes to this file will be lost when the code is regenerated.\r\n//------------------------------------------------------------------------------\r\nnamespace rec TestFields\r\n\r\nmodule Test1 =\r\n    open Example\r\n\r\n    let one (x : Test1) = x.one\r\n    let two (x : Test1) = x.two\r\n    let three (x : Test1) = x.three\r\n    let four (x : Test1) = x.four\r\n\r\n    let create (one : Test1) (two : string) (three : float) (four : float32) : Test1 =\r\n        { one = one\r\n          two = two\r\n          three = three\r\n          four = four }\r\n\r\n    let map (mapone : int -> int) (maptwo : string -> string) (mapthree : float -> float) (mapfour : float32 -> float32) (record': Test1) =\r\n      { record' with\r\n          one = mapone record'.one\r\n          two = maptwo record'.two\r\n          three = mapthree record'.three\r\n          four = mapfour record'.four }\r\n```\r\n\r\nThe fields plugin generates a `map` for each field in the input record, a `create` function taking each field, and a `map` function that takes one function per field in the input record.\r\n\r\nThe map functions for each field are useful in situations where you just want to use a single field from a record in a lambda like a list of records:\r\n```fsharp\r\nlet records = [{one = \"a\"; two = \"aa\"; three = 42.0; four = 172.0f}\r\n               {one = \"b\"; two = \"bb\"; three = 42.0; four = 172.0f}]\r\n records |> List.sortBy Test1.one\r\n```\r\n\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/configuration.html","title":"Configuration And Plugins","content":"\r\n# Configuration\r\n\r\nMyriad uses a configuration file called `myriad.toml` which uses the [toml format](https://toml.io/en/).  Myriad looks in the current directory fro this file but it can be configured by placing `MyriadConfigFile` in your project file like this:\r\n\r\n```msbuild\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net5.0</TargetFramework>\r\n    <OutputType>Exe</OutputType>\r\n    <MyriadConfigFile>myConfig.toml</MyriadConfigFile>\r\n  </PropertyGroup>\r\n...\r\n```\r\n\r\nThe configuration section for the built in plugins is very simple, the configuration name or key is passed in by either the plugins generator attribute, in the case of the fields plugin:\r\n\r\n```\r\n[<Generator.Fields \"fields\">]\r\ntype Test1 = { one: int; two: string; three: float; four: float32 }\r\n\r\n```\r\n\r\nThe configuration key is \"fields\", if we now look at the `myriad.toml` file it looks like this:\r\n\r\n```toml\r\n[fields]\r\nnamespace = \"TestFields\"\r\n```\r\n\r\nYou can see that there is a `namespace` key that is set to \"TestFields\".  Using an attribute like this you can configure your plugin to take further information on how to generate the code.  \r\n\r\nThere is another mechanism of specifying what configuration a plugin will use and that is by using an MSBuild property `MyriadConfigKey` as follows:\r\n\r\n```xml\r\n<Compile Include=\"ArbitaryFile.fs\">\r\n    <MyriadFile>Test.txt</MyriadFile>\r\n    <MyriadConfigKey>example1</MyriadConfigKey>\r\n</Compile>\r\n```\r\n\r\nThe configuration key `example1` would be passed to the plugin so that it could be consumed.  This is used in the `Myriad.Plugin.Example1` plugin and use uses configuration to specify the `namespace` used.  \r\n\r\n# Writing plugins to consume configuration\r\n\r\nThe plugin interface receives this key via: `GeneratorContext` . `ConfigKey`:\r\n\r\n```fsharp\r\ntype GeneratorContext = {\r\n    ConfigKey: string option\r\n    ConfigGetter: string -> (string * obj) seq\r\n    InputFileName: string\r\n}\r\n\r\ntype IMyriadGenerator =\r\n    abstract member ValidInputExtensions: string seq\r\n    abstract member Generate: GeneratorContext -> FsAst.AstRcd.SynModuleOrNamespaceRcd list\r\n```\r\n\r\nValidInputExtensions is used so a plugin is tied to certain file types as input, if you plugin generating ast fragments from java files then you would add `.java` to the `ValidInputExtensions` implementation for example.  \r\n\r\n```fsharp\r\n    interface IMyriadGenerator with\r\n        member __.ValidInputExtensions = seq {\".java\"}\r\n        //...\r\n```\r\n\r\nWhile we are discussing the `IMyriadGenerator` interface lets discuss the `Generate` member:\r\n\r\nGenerate takes a `GeneratorContext` which contains the `ConfigKey` as mentioned above, the `ConfigGetter` : `string -> (string * obj) seq` which is a mean to allow access to the `myriad.toml` file, you give the function the configuration ket you wish to receive and it returns the configuration.  Finally a `InputFileName` is also passed in so you can load or parse your input files ready to generate an AST.  If you look at the included plugins you can see the mechanism for extracting and building AST fragments for reference.  \r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/debugging.html","title":"Debugging","content":"\r\n# Debugging\r\n\r\nTo debug Myriad, you can use the following two command line options:\r\n\r\n* `--verbose` — write diagnostic logs out to standard out\r\n* `--wait-for-debugger` — causes Myriad to wait for a debugger to attach to the Myriad process\r\n\r\nThese can be triggered from msbuild by the `<MyriadSdkVerboseOutput>true</MyriadSdkVerboseOutput>` and `<MyriadSdkWaitForDebugger>true</MyriadSdkWaitForDebugger>` properties, respectively."},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/external-plugins.html","title":"External Plugins","content":"\r\n# Using external plugins\r\n\r\nTo consume external plugins that aren't included in the `Myriad.Plugins` package, you must register them with Myriad. If you are using the CLI tool then the way to do this is by passing in the `--plugin <path to dll>` command-line argument. If you are using MSBuild then this can be done by adding to the `MyriadSdkGenerator` property to your project file:\r\n\r\n```xml\r\n<ItemGroup>\r\n    <MyriadSdkGenerator Include=\"<path to plugin dll>\" />\r\n</ItemGroup>\r\n```\r\n\r\nFor example, if you had a project layout like this:\r\n\r\n```\r\n\\src\r\n-\\GeneratorLib\r\n - Generator.fs\r\n - Generator.fsproj\r\n-\\GeneratorTests\r\n - Tests.fs\r\n - GeneratorTests.fsproj\r\n```\r\n\r\nYou would add the following to Generator.fsproj:\r\n```xml\r\n  <ItemGroup>\r\n    <Content Include=\"build\\Generator.props\">\r\n      <Pack>true</Pack>\r\n      <PackagePath>%(Identity)</PackagePath>\r\n      <Visible>true</Visible>\r\n    </Content>\r\n  </ItemGroup>\r\n```\r\n\r\nThen add a new folder `build` with the `Generator.props` file within:\r\n```xml\r\n<Project>\r\n    <ItemGroup>\r\n        <MyriadSdkGenerator Include=\"$(MSBuildThisFileDirectory)/../lib/netstandard2.1/Generator.dll\" />\r\n    </ItemGroup>\r\n</Project>\r\n```\r\n\r\nOften an additional props file (In this smaple the file would be `Generator.InTest.props`) is used to make testing easier.  The matching element for the tests fsproj would be something like this:\r\n\r\n```xml\r\n<Project>\r\n    <ItemGroup>\r\n        <MyriadSdkGenerator Include=\"$(MSBuildThisFileDirectory)/../bin/$(Configuration)/netstandard2.1/Generator.dll\" />\r\n    </ItemGroup>\r\n</Project>\r\n```\r\n\r\nNotice the Include path is pointing locally rather than within the packaged nuget folder structure.\r\n\r\nIn your testing `fsproj` you would add the following to allow the plugin to be used locally rather that having to consume a nuget package:\r\n\r\n```xml\r\n<!-- include plugin -->\r\n<Import Project=\"<Path to Generator plugin location>\\build\\Myriad.Plugins.InTest.props\" />\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/msbuild-usage.html","title":"MSBuild usage","content":"\r\n# MSBuild usage\r\n\r\nPlugins for Myriad are supplied by simply including the nuget package in your project, the nuget infrastructure supplies the necessary MSBuild props and targets so that the plugin is used by Myriad automatically. Following the source for the fields plugin can be used as reference until more details about authoring plugins is created.\r\n\r\nTo use Myriad via its MSBuild support you add the `Myriad.Core` and `Myriad.Sdk` package references:\r\n```xml\r\n    <ItemGroup>\r\n      <PackageReference Include=\"Myriad.Core\" Version=\"0.5.1\" />\r\n      <PackageReference Include=\"Myriad.Sdk\" Version=\"0.5.1\" />\r\n      <PackageReference Include=\"Myriad.Plugins\" Version=\"0.5.1\" /> <!-- Built in set of plugins -->\r\n    </ItemGroup>\r\n```\r\n\r\nAn input file is specified by using the usual `Compile` element:\r\n```xml\r\n<Compile Include=\"Generated.fs\">\r\n    <MyriadFile>Library.fs</MyriadFile>\r\n</Compile>\r\n```\r\n\r\nThis is configuring Myriad so that a file called `Generated.fs` will be included in the build using `Library.fs` as input.  \r\n\r\nMyriad works by using plugins to generate code.  A plugin called fields is included with Myriad which takes inspiration from OCamls [ppx_fields_conv](https://github.com/janestreet/ppx_fields_conv) plugin of the same name.  There are also plugins included to generate discriminated union helpers adn record lenses.\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//index.html","title":"Myriad Overview","content":"\r\n# Myriad\r\n\r\nMyriad is a code generator, it can take an arbitrary file and uses it to produce actual F# code.  The file can be anything from a plain txt file to an F# file.  \r\n\r\nMyriad can be used via MSBuild as part of a your project file, or standalone from its CLI tool.\r\n\r\nThe idea behind Myriad is to un-complicate, as far as possible, the ability to generate code and do meta-programming in F#. By meta-programming in F# I mean generating actual F# types and constructs like discriminated unions and records, not just IL output or simple classes like type providers.\r\n\r\nMyriad is an evolution of the ideas I developed while working with F#'s type providers and other meta-programming functionality like quotations and AST manipulation. Myriad aims to make it easy to extend the compiler via Myriad plugins rather than modifying or adjusting Type Providers and other F# improvements that would take a long time to be developed and released.  \r\n\r\nThe idea is you write a Myriad plugin that works on a particular file type, this could be a fragment of AST input or a proto file etc.  The plugin is supplied the file name various helpers in the library make it easier to produce the AST output with the final form being source code that is built into your project.  The advantages of this are the compiler can optimise the generated code and tooling can operate effectively too as you can navigate the generated code as normal.\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/creating-a-generator.html","title":"Creating a Generator","content":"\r\n# Building a Generator from scratch  \r\n\r\n![Generator](/myriad/static/images/pexels-spacex-586024.jpg)\r\n\r\nIm sorry there is no step by step guide (Yet) you can use the following as reference until I get around to writing it:\r\n\r\n[Applied Metaprogramming with Myriad and Falanx](https://7sharp9.github.io/fsharp/2019-04-24-applied-metaprogramming-with-myriad/)  - This is a video I made for my YouTube chanell which covers some details on Myriad.  \r\n\r\n\r\n[Myriad Intro](https://7sharp9.github.io/fsharp/2019-11-06-myriad-intro/) - This is a blog post I wrote around the time of Applied Metaprogramming with Myriad and Falanx which has details of making a generator that produces a simple module:\r\n:\r\n\r\n```fsharp\r\nmodule example1 =\r\n    let fourtyTwo = 42\r\n```\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/du-extensions.html","title":"DU Extensions","content":"\r\nThe input file in this example `Library.fs` looks like this:\r\n\r\n```fsharp\r\nnamespace Example\r\nopen Myriad.Plugins\r\n\r\n[<Generator.DuCases \"dus\" >]\r\ntype Currency =\r\n| CAD\r\n| PLN\r\n| EUR\r\n| USD\r\n| Custom of string\r\n\r\n```\r\n\r\nAn attribute is used by the plugin so that the code generator plugin knows which parts of the input AST are to be used by the plugin.  If you had several records and you only wanted the fields plugin to operate on `Currency` then the attribute would be used like in the example about to only apply `Generator.DuCases` to `Currency`.  Note, if you wanted a plugin that just needs the whole input AST then there is no need to provide an input.  Myriad aims to be a library rather than a full framework that ties you to the mechanism used to input and generate code.\r\n\r\nTo control what namespace is used as well as supplying any other information to plugins a `myriad.toml` configuration file is used.  This is specified in the generator attribute, in the example above you can see the configuration section is `dus`  `[<Generator.DuCases \"dus\" >]`.  The corresponding `myriad.toml` file looks as follows:  \r\n\r\n```toml\r\n[dus]\r\nnamespace = \"TestDus\"\r\n```\r\n\r\nThe DuCases plugin uses only a single configuration key `namespace` to control the resulting namespace the DuCases are generated\r\n\r\nThe fields plugin in this example will generate the following code at prebuild time and compile the code into your assembly:\r\n```fsharp\r\n//------------------------------------------------------------------------------\r\n//        This code was generated by myriad.\r\n//        Changes to this file will be lost when the code is regenerated.\r\n//------------------------------------------------------------------------------\r\nnamespace rec TestDus\r\n\r\nmodule Currency =\r\n    open Input\r\n\r\n    let toString (x: Currency) =\r\n        match x with\r\n        | CAD -> \"CAD\"\r\n        | PLN -> \"PLN\"\r\n        | EUR -> \"EUR\"\r\n        | USD -> \"USD\"\r\n        | Custom _ -> \"Custom\"\r\n\r\n    let fromString (x: string) =\r\n        match x with\r\n        | \"CAD\" -> Some CAD\r\n        | \"PLN\" -> Some PLN\r\n        | \"EUR\" -> Some EUR\r\n        | \"USD\" -> Some USD\r\n        | _ -> None\r\n\r\n    let toTag (x: Currency) =\r\n        match x with\r\n        | CAD -> 0\r\n        | PLN -> 1\r\n        | EUR -> 2\r\n        | USD -> 3\r\n        | Custom _ -> 4\r\n\r\n    let isCAD (x: Currency) =\r\n        match x with\r\n        | CAD -> true\r\n        | _ -> false\r\n\r\n    let isPLN (x: Currency) =\r\n        match x with\r\n        | PLN -> true\r\n        | _ -> false\r\n\r\n    let isEUR (x: Currency) =\r\n        match x with\r\n        | EUR -> true\r\n        | _ -> false\r\n\r\n    let isUSD (x: Currency) =\r\n        match x with\r\n        | USD -> true\r\n        | _ -> false\r\n\r\n    let isCustom (x: Currency) =\r\n        match x with\r\n        | Custom _ -> true\r\n        | _ -> false\r\n```\r\n\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/lenses.html","title":"Lenses","content":"\r\n# Lenses\r\n\r\nMyriad can also generate [lenses](https://fsprojects.github.io/FSharpPlus/tutorial.html#Lens) for records and single-case discriminated unions.\r\nLens is a pair of a getter and a setter for one property of the type and allows, given the object, to get the value of the property or to update it creating a new object. The advantage of lenses is an ability to combine them to read or update nested fields of the object.\r\n\r\nTo create lenses for your type, first annotate the type for which you want lenses to be generated with `Generator.Lenses` attribute, note the \"lens\" parameter specifies which configuration key is used with the plugin, this is used to specify which namespace is generated via the `myriad.toml` configuration file:\r\n\r\n```fsharp\r\n[<Generator.Lenses(\"lens\")>]\r\ntype Record =\r\n    { one: int\r\n      two: string }\r\n```\r\n\r\nMyriad will generate the following code:\r\n\r\n```fsharp\r\nmodule RecordLenses =\r\n    let one = (fun (x: Test1) -> x.one), (fun (x: Test1) (value: int) -> { x with one = value })\r\n    let two = (fun (x: Test1) -> x.two), (fun (x: Test1) (value: string) -> { x with two = value })\r\n```\r\n\r\nOften lenses are defined as a single-case union around a pair of getter and setter. Myriad is also capable of adding the invocation of such DU's constructor.\r\n\r\nTo achieve this, add the type `Lens` to the `Generator.Lenses` attribute, specifying the name of the DU constructor: `[<Generator.Lenses(\"lens\", \"Lens\")>]`, and Myriad will generate this code:\r\n\r\n```fsharp\r\nmodule RecordLenses =\r\n    let one = Lens((fun (x: Test1) -> x.one), (fun (x: Test1) (value: int) -> { x with one = value }))\r\n    let two = Lens((fun (x: Test1) -> x.two), (fun (x: Test1) (value: string) -> { x with two = value }))\r\n```\r\n\r\nYou can provide the name of DU constructor in several ways:\r\n- As a string: `[<Generator.Lenses(\"lens\", \"Lens\")>]`;\r\n- Or as a type: `[<Generator.Lenses(\"lens\", typedefof<Lens<_, _>>)>]` or `[<Generator.Lenses(\"lens\", typeof<Lens<_, _>>)>]`.\r\n\r\nIf the `Lens` type is in different namespace/module than the type decorated with the attribute, provide the full name of the `Lens` constructor: `[<Generator.Lenses(\"Namespace.And.Module.Of.Lens\")>]`."},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/record-fields.html","title":"Record Extensions","content":"\r\nThe input file in this example `Library.fs` looks like this:\r\n\r\n```fsharp\r\nnamespace Example\r\nopen Myriad.Plugins\r\n\r\n[<Generator.Fields \"fields\">]\r\ntype Test1 = { one: int; two: string; three: float; four: float32 }\r\ntype Test2 = { one: Test1; two: string }\r\n```\r\n\r\nAn attribute is used by the fields plugin so that the code generator knows which parts of the input AST should be consumed by the plugin.  If you had several records and you only wanted the fields plugin to operate on `Test1` then the attribute would be used like in the example about to only apply `Generator.Fields` to the `Test1` record.  Note, if you wanted a plugin that just processes the whole input then there is no need to provide such an attribute.  Myriad aims to be a library rather than a full framework that ties you to the mechanism used to input and generate code, its up to you how you generate the code, Myriad just aims to help to make this as painless and flexible as possible.\r\n\r\nTo control what namespace is used as well as supplying any other information to plugins a `myriad.toml` configuration file is used.  This is specified in the generator attribute, in the example above you can see the configuration section is `fields`  `[<Generator.Fields \"fields\">]`.  The corresponding `myriad.toml` file looks as follows:  \r\n\r\n```toml\r\n[fields]\r\nnamespace = \"TestFields\"\r\n```\r\n\r\nThe fields plugin uses only a single configuration key `namespace` to control the resulting namespace the record helpers are generated\r\n\r\n\r\nThe fields plugin in this example will generate the following code at prebuild and compile the code into your assembly:\r\n```fsharp\r\n//------------------------------------------------------------------------------\r\n//        This code was generated by myriad.\r\n//        Changes to this file will be lost when the code is regenerated.\r\n//------------------------------------------------------------------------------\r\nnamespace rec TestFields\r\n\r\nmodule Test1 =\r\n    open Example\r\n\r\n    let one (x : Test1) = x.one\r\n    let two (x : Test1) = x.two\r\n    let three (x : Test1) = x.three\r\n    let four (x : Test1) = x.four\r\n\r\n    let create (one : Test1) (two : string) (three : float) (four : float32) : Test1 =\r\n        { one = one\r\n          two = two\r\n          three = three\r\n          four = four }\r\n\r\n    let map (mapone : int -> int) (maptwo : string -> string) (mapthree : float -> float) (mapfour : float32 -> float32) (record': Test1) =\r\n      { record' with\r\n          one = mapone record'.one\r\n          two = maptwo record'.two\r\n          three = mapthree record'.three\r\n          four = mapfour record'.four }\r\n```\r\n\r\nThe fields plugin generates a `map` for each field in the input record, a `create` function taking each field, and a `map` function that takes one function per field in the input record.\r\n\r\nThe map functions for each field are useful in situations where you just want to use a single field from a record in a lambda like a list of records:\r\n```fsharp\r\nlet records = [{one = \"a\"; two = \"aa\"; three = 42.0; four = 172.0f}\r\n               {one = \"b\"; two = \"bb\"; three = 42.0; four = 172.0f}]\r\n records |> List.sortBy Test1.one\r\n```\r\n\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/configuration.html","title":"Configuration And Plugins","content":"\r\n# Configuration\r\n\r\nMyriad uses a configuration file called `myriad.toml` which uses the [toml format](https://toml.io/en/).  Myriad looks in the current directory fro this file but it can be configured by placing `MyriadConfigFile` in your project file like this:\r\n\r\n```msbuild\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net5.0</TargetFramework>\r\n    <OutputType>Exe</OutputType>\r\n    <MyriadConfigFile>myConfig.toml</MyriadConfigFile>\r\n  </PropertyGroup>\r\n...\r\n```\r\n\r\nThe configuration section for the built in plugins is very simple, the configuration name or key is passed in by either the plugins generator attribute, in the case of the fields plugin:\r\n\r\n```\r\n[<Generator.Fields \"fields\">]\r\ntype Test1 = { one: int; two: string; three: float; four: float32 }\r\n\r\n```\r\n\r\nThe configuration key is \"fields\", if we now look at the `myriad.toml` file it looks like this:\r\n\r\n```toml\r\n[fields]\r\nnamespace = \"TestFields\"\r\n```\r\n\r\nYou can see that there is a `namespace` key that is set to \"TestFields\".  Using an attribute like this you can configure your plugin to take further information on how to generate the code.  \r\n\r\nThere is another mechanism of specifying what configuration a plugin will use and that is by using an MSBuild property `MyriadConfigKey` as follows:\r\n\r\n```xml\r\n<Compile Include=\"ArbitaryFile.fs\">\r\n    <MyriadFile>Test.txt</MyriadFile>\r\n    <MyriadConfigKey>example1</MyriadConfigKey>\r\n</Compile>\r\n```\r\n\r\nThe configuration key `example1` would be passed to the plugin so that it could be consumed.  This is used in the `Myriad.Plugin.Example1` plugin and use uses configuration to specify the `namespace` used.  \r\n\r\n# Writing plugins to consume configuration\r\n\r\nThe plugin interface receives this key via: `GeneratorContext` . `ConfigKey`:\r\n\r\n```fsharp\r\ntype GeneratorContext = {\r\n    ConfigKey: string option\r\n    ConfigGetter: string -> (string * obj) seq\r\n    InputFileName: string\r\n}\r\n\r\ntype IMyriadGenerator =\r\n    abstract member ValidInputExtensions: string seq\r\n    abstract member Generate: GeneratorContext -> FsAst.AstRcd.SynModuleOrNamespaceRcd list\r\n```\r\n\r\nValidInputExtensions is used so a plugin is tied to certain file types as input, if you plugin generating ast fragments from java files then you would add `.java` to the `ValidInputExtensions` implementation for example.  \r\n\r\n```fsharp\r\n    interface IMyriadGenerator with\r\n        member __.ValidInputExtensions = seq {\".java\"}\r\n        //...\r\n```\r\n\r\nWhile we are discussing the `IMyriadGenerator` interface lets discuss the `Generate` member:\r\n\r\nGenerate takes a `GeneratorContext` which contains the `ConfigKey` as mentioned above, the `ConfigGetter` : `string -> (string * obj) seq` which is a mean to allow access to the `myriad.toml` file, you give the function the configuration ket you wish to receive and it returns the configuration.  Finally a `InputFileName` is also passed in so you can load or parse your input files ready to generate an AST.  If you look at the included plugins you can see the mechanism for extracting and building AST fragments for reference.  \r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/debugging.html","title":"Debugging","content":"\r\n# Debugging\r\n\r\nTo debug Myriad, you can use the following two command line options:\r\n\r\n* `--verbose` — write diagnostic logs out to standard out\r\n* `--wait-for-debugger` — causes Myriad to wait for a debugger to attach to the Myriad process\r\n\r\nThese can be triggered from msbuild by the `<MyriadSdkVerboseOutput>true</MyriadSdkVerboseOutput>` and `<MyriadSdkWaitForDebugger>true</MyriadSdkWaitForDebugger>` properties, respectively."},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/external-plugins.html","title":"External Plugins","content":"\r\n# Using external plugins\r\n\r\nTo consume external plugins that aren't included in the `Myriad.Plugins` package, you must register them with Myriad. If you are using the CLI tool then the way to do this is by passing in the `--plugin <path to dll>` command-line argument. If you are using MSBuild then this can be done by adding to the `MyriadSdkGenerator` property to your project file:\r\n\r\n```xml\r\n<ItemGroup>\r\n    <MyriadSdkGenerator Include=\"<path to plugin dll>\" />\r\n</ItemGroup>\r\n```\r\n\r\nFor example, if you had a project layout like this:\r\n\r\n```\r\n\\src\r\n-\\GeneratorLib\r\n - Generator.fs\r\n - Generator.fsproj\r\n-\\GeneratorTests\r\n - Tests.fs\r\n - GeneratorTests.fsproj\r\n```\r\n\r\nYou would add the following to Generator.fsproj:\r\n```xml\r\n  <ItemGroup>\r\n    <Content Include=\"build\\Generator.props\">\r\n      <Pack>true</Pack>\r\n      <PackagePath>%(Identity)</PackagePath>\r\n      <Visible>true</Visible>\r\n    </Content>\r\n  </ItemGroup>\r\n```\r\n\r\nThen add a new folder `build` with the `Generator.props` file within:\r\n```xml\r\n<Project>\r\n    <ItemGroup>\r\n        <MyriadSdkGenerator Include=\"$(MSBuildThisFileDirectory)/../lib/netstandard2.1/Generator.dll\" />\r\n    </ItemGroup>\r\n</Project>\r\n```\r\n\r\nOften an additional props file (In this smaple the file would be `Generator.InTest.props`) is used to make testing easier.  The matching element for the tests fsproj would be something like this:\r\n\r\n```xml\r\n<Project>\r\n    <ItemGroup>\r\n        <MyriadSdkGenerator Include=\"$(MSBuildThisFileDirectory)/../bin/$(Configuration)/netstandard2.1/Generator.dll\" />\r\n    </ItemGroup>\r\n</Project>\r\n```\r\n\r\nNotice the Include path is pointing locally rather than within the packaged nuget folder structure.\r\n\r\nIn your testing `fsproj` you would add the following to allow the plugin to be used locally rather that having to consume a nuget package:\r\n\r\n```xml\r\n<!-- include plugin -->\r\n<Import Project=\"<Path to Generator plugin location>\\build\\Myriad.Plugins.InTest.props\" />\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/msbuild-usage.html","title":"MSBuild usage","content":"\r\n# MSBuild usage\r\n\r\nPlugins for Myriad are supplied by simply including the nuget package in your project, the nuget infrastructure supplies the necessary MSBuild props and targets so that the plugin is used by Myriad automatically. Following the source for the fields plugin can be used as reference until more details about authoring plugins is created.\r\n\r\nTo use Myriad via its MSBuild support you add the `Myriad.Core` and `Myriad.Sdk` package references:\r\n```xml\r\n    <ItemGroup>\r\n      <PackageReference Include=\"Myriad.Core\" Version=\"0.5.1\" />\r\n      <PackageReference Include=\"Myriad.Sdk\" Version=\"0.5.1\" />\r\n      <PackageReference Include=\"Myriad.Plugins\" Version=\"0.5.1\" /> <!-- Built in set of plugins -->\r\n    </ItemGroup>\r\n```\r\n\r\nAn input file is specified by using the usual `Compile` element:\r\n```xml\r\n<Compile Include=\"Generated.fs\">\r\n    <MyriadFile>Library.fs</MyriadFile>\r\n</Compile>\r\n```\r\n\r\nThis is configuring Myriad so that a file called `Generated.fs` will be included in the build using `Library.fs` as input.  \r\n\r\nMyriad works by using plugins to generate code.  A plugin called fields is included with Myriad which takes inspiration from OCamls [ppx_fields_conv](https://github.com/janestreet/ppx_fields_conv) plugin of the same name.  There are also plugins included to generate discriminated union helpers adn record lenses.\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Core/index.html","title":"Myriad.Core - API Reference","content":"Myriad.Core \n Myriad.Core"},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Core/myriad-core-ast.html","title":"Ast","content":"Ast \n  \n  \n  \n fromFilename  typeNameMatches  getAttributeConstants  hasAttributeWithConst  hasAttributeWithName  hasAttribute  getAttribute  extractTypeDefn  isRecord  isDu  extractRecords  extractDU  \n "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Core/myriad-core-generatorcontext.html","title":"GeneratorContext","content":"GeneratorContext \n  \n ConfigKey  ConfigGetter  InputFileName "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Core/myriad-core-imyriadgenerator.html","title":"IMyriadGenerator","content":"IMyriadGenerator \n  \n Generate  ValidInputExtensions "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Core/myriad-core-myriadgeneratorattribute.html","title":"MyriadGeneratorAttribute","content":"MyriadGeneratorAttribute \n  \n ( .ctor )  Name "},{"uri":"https://moiraesoftware.github.io/myriad//index.html","title":"Myriad Overview","content":"\r\n# Myriad\r\n\r\nMyriad is a code generator, it can take an arbitrary file and uses it to produce actual F# code.  The file can be anything from a plain txt file to an F# file.  \r\n\r\nMyriad can be used via MSBuild as part of a your project file, or standalone from its CLI tool.\r\n\r\nThe idea behind Myriad is to un-complicate, as far as possible, the ability to generate code and do meta-programming in F#. By meta-programming in F# I mean generating actual F# types and constructs like discriminated unions and records, not just IL output or simple classes like type providers.\r\n\r\nMyriad is an evolution of the ideas I developed while working with F#'s type providers and other meta-programming functionality like quotations and AST manipulation. Myriad aims to make it easy to extend the compiler via Myriad plugins rather than modifying or adjusting Type Providers and other F# improvements that would take a long time to be developed and released.  \r\n\r\nThe idea is you write a Myriad plugin that works on a particular file type, this could be a fragment of AST input or a proto file etc.  The plugin is supplied the file name various helpers in the library make it easier to produce the AST output with the final form being source code that is built into your project.  The advantages of this are the compiler can optimise the generated code and tooling can operate effectively too as you can navigate the generated code as normal.\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/creating-a-generator.html","title":"Creating a Generator","content":"\r\n# Building a Generator from scratch  \r\n\r\n![Generator](/myriad/static/images/pexels-spacex-586024.jpg)\r\n\r\nIm sorry there is no step by step guide (Yet) you can use the following as reference until I get around to writing it:\r\n\r\n[Applied Metaprogramming with Myriad and Falanx](https://7sharp9.github.io/fsharp/2019-04-24-applied-metaprogramming-with-myriad/)  - This is a video I made for my YouTube chanell which covers some details on Myriad.  \r\n\r\n\r\n[Myriad Intro](https://7sharp9.github.io/fsharp/2019-11-06-myriad-intro/) - This is a blog post I wrote around the time of Applied Metaprogramming with Myriad and Falanx which has details of making a generator that produces a simple module:\r\n:\r\n\r\n```fsharp\r\nmodule example1 =\r\n    let fourtyTwo = 42\r\n```\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/du-extensions.html","title":"DU Extensions","content":"\r\nThe input file in this example `Library.fs` looks like this:\r\n\r\n```fsharp\r\nnamespace Example\r\nopen Myriad.Plugins\r\n\r\n[<Generator.DuCases \"dus\" >]\r\ntype Currency =\r\n| CAD\r\n| PLN\r\n| EUR\r\n| USD\r\n| Custom of string\r\n\r\n```\r\n\r\nAn attribute is used by the plugin so that the code generator plugin knows which parts of the input AST are to be used by the plugin.  If you had several records and you only wanted the fields plugin to operate on `Currency` then the attribute would be used like in the example about to only apply `Generator.DuCases` to `Currency`.  Note, if you wanted a plugin that just needs the whole input AST then there is no need to provide an input.  Myriad aims to be a library rather than a full framework that ties you to the mechanism used to input and generate code.\r\n\r\nTo control what namespace is used as well as supplying any other information to plugins a `myriad.toml` configuration file is used.  This is specified in the generator attribute, in the example above you can see the configuration section is `dus`  `[<Generator.DuCases \"dus\" >]`.  The corresponding `myriad.toml` file looks as follows:  \r\n\r\n```toml\r\n[dus]\r\nnamespace = \"TestDus\"\r\n```\r\n\r\nThe DuCases plugin uses only a single configuration key `namespace` to control the resulting namespace the DuCases are generated\r\n\r\nThe fields plugin in this example will generate the following code at prebuild time and compile the code into your assembly:\r\n```fsharp\r\n//------------------------------------------------------------------------------\r\n//        This code was generated by myriad.\r\n//        Changes to this file will be lost when the code is regenerated.\r\n//------------------------------------------------------------------------------\r\nnamespace rec TestDus\r\n\r\nmodule Currency =\r\n    open Input\r\n\r\n    let toString (x: Currency) =\r\n        match x with\r\n        | CAD -> \"CAD\"\r\n        | PLN -> \"PLN\"\r\n        | EUR -> \"EUR\"\r\n        | USD -> \"USD\"\r\n        | Custom _ -> \"Custom\"\r\n\r\n    let fromString (x: string) =\r\n        match x with\r\n        | \"CAD\" -> Some CAD\r\n        | \"PLN\" -> Some PLN\r\n        | \"EUR\" -> Some EUR\r\n        | \"USD\" -> Some USD\r\n        | _ -> None\r\n\r\n    let toTag (x: Currency) =\r\n        match x with\r\n        | CAD -> 0\r\n        | PLN -> 1\r\n        | EUR -> 2\r\n        | USD -> 3\r\n        | Custom _ -> 4\r\n\r\n    let isCAD (x: Currency) =\r\n        match x with\r\n        | CAD -> true\r\n        | _ -> false\r\n\r\n    let isPLN (x: Currency) =\r\n        match x with\r\n        | PLN -> true\r\n        | _ -> false\r\n\r\n    let isEUR (x: Currency) =\r\n        match x with\r\n        | EUR -> true\r\n        | _ -> false\r\n\r\n    let isUSD (x: Currency) =\r\n        match x with\r\n        | USD -> true\r\n        | _ -> false\r\n\r\n    let isCustom (x: Currency) =\r\n        match x with\r\n        | Custom _ -> true\r\n        | _ -> false\r\n```\r\n\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/lenses.html","title":"Lenses","content":"\r\n# Lenses\r\n\r\nMyriad can also generate [lenses](https://fsprojects.github.io/FSharpPlus/tutorial.html#Lens) for records and single-case discriminated unions.\r\nLens is a pair of a getter and a setter for one property of the type and allows, given the object, to get the value of the property or to update it creating a new object. The advantage of lenses is an ability to combine them to read or update nested fields of the object.\r\n\r\nTo create lenses for your type, first annotate the type for which you want lenses to be generated with `Generator.Lenses` attribute, note the \"lens\" parameter specifies which configuration key is used with the plugin, this is used to specify which namespace is generated via the `myriad.toml` configuration file:\r\n\r\n```fsharp\r\n[<Generator.Lenses(\"lens\")>]\r\ntype Record =\r\n    { one: int\r\n      two: string }\r\n```\r\n\r\nMyriad will generate the following code:\r\n\r\n```fsharp\r\nmodule RecordLenses =\r\n    let one = (fun (x: Test1) -> x.one), (fun (x: Test1) (value: int) -> { x with one = value })\r\n    let two = (fun (x: Test1) -> x.two), (fun (x: Test1) (value: string) -> { x with two = value })\r\n```\r\n\r\nOften lenses are defined as a single-case union around a pair of getter and setter. Myriad is also capable of adding the invocation of such DU's constructor.\r\n\r\nTo achieve this, add the type `Lens` to the `Generator.Lenses` attribute, specifying the name of the DU constructor: `[<Generator.Lenses(\"lens\", \"Lens\")>]`, and Myriad will generate this code:\r\n\r\n```fsharp\r\nmodule RecordLenses =\r\n    let one = Lens((fun (x: Test1) -> x.one), (fun (x: Test1) (value: int) -> { x with one = value }))\r\n    let two = Lens((fun (x: Test1) -> x.two), (fun (x: Test1) (value: string) -> { x with two = value }))\r\n```\r\n\r\nYou can provide the name of DU constructor in several ways:\r\n- As a string: `[<Generator.Lenses(\"lens\", \"Lens\")>]`;\r\n- Or as a type: `[<Generator.Lenses(\"lens\", typedefof<Lens<_, _>>)>]` or `[<Generator.Lenses(\"lens\", typeof<Lens<_, _>>)>]`.\r\n\r\nIf the `Lens` type is in different namespace/module than the type decorated with the attribute, provide the full name of the `Lens` constructor: `[<Generator.Lenses(\"Namespace.And.Module.Of.Lens\")>]`."},{"uri":"https://moiraesoftware.github.io/myriad//how-tos/record-fields.html","title":"Record Extensions","content":"\r\nThe input file in this example `Library.fs` looks like this:\r\n\r\n```fsharp\r\nnamespace Example\r\nopen Myriad.Plugins\r\n\r\n[<Generator.Fields \"fields\">]\r\ntype Test1 = { one: int; two: string; three: float; four: float32 }\r\ntype Test2 = { one: Test1; two: string }\r\n```\r\n\r\nAn attribute is used by the fields plugin so that the code generator knows which parts of the input AST should be consumed by the plugin.  If you had several records and you only wanted the fields plugin to operate on `Test1` then the attribute would be used like in the example about to only apply `Generator.Fields` to the `Test1` record.  Note, if you wanted a plugin that just processes the whole input then there is no need to provide such an attribute.  Myriad aims to be a library rather than a full framework that ties you to the mechanism used to input and generate code, its up to you how you generate the code, Myriad just aims to help to make this as painless and flexible as possible.\r\n\r\nTo control what namespace is used as well as supplying any other information to plugins a `myriad.toml` configuration file is used.  This is specified in the generator attribute, in the example above you can see the configuration section is `fields`  `[<Generator.Fields \"fields\">]`.  The corresponding `myriad.toml` file looks as follows:  \r\n\r\n```toml\r\n[fields]\r\nnamespace = \"TestFields\"\r\n```\r\n\r\nThe fields plugin uses only a single configuration key `namespace` to control the resulting namespace the record helpers are generated\r\n\r\n\r\nThe fields plugin in this example will generate the following code at prebuild and compile the code into your assembly:\r\n```fsharp\r\n//------------------------------------------------------------------------------\r\n//        This code was generated by myriad.\r\n//        Changes to this file will be lost when the code is regenerated.\r\n//------------------------------------------------------------------------------\r\nnamespace rec TestFields\r\n\r\nmodule Test1 =\r\n    open Example\r\n\r\n    let one (x : Test1) = x.one\r\n    let two (x : Test1) = x.two\r\n    let three (x : Test1) = x.three\r\n    let four (x : Test1) = x.four\r\n\r\n    let create (one : Test1) (two : string) (three : float) (four : float32) : Test1 =\r\n        { one = one\r\n          two = two\r\n          three = three\r\n          four = four }\r\n\r\n    let map (mapone : int -> int) (maptwo : string -> string) (mapthree : float -> float) (mapfour : float32 -> float32) (record': Test1) =\r\n      { record' with\r\n          one = mapone record'.one\r\n          two = maptwo record'.two\r\n          three = mapthree record'.three\r\n          four = mapfour record'.four }\r\n```\r\n\r\nThe fields plugin generates a `map` for each field in the input record, a `create` function taking each field, and a `map` function that takes one function per field in the input record.\r\n\r\nThe map functions for each field are useful in situations where you just want to use a single field from a record in a lambda like a list of records:\r\n```fsharp\r\nlet records = [{one = \"a\"; two = \"aa\"; three = 42.0; four = 172.0f}\r\n               {one = \"b\"; two = \"bb\"; three = 42.0; four = 172.0f}]\r\n records |> List.sortBy Test1.one\r\n```\r\n\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/configuration.html","title":"Configuration And Plugins","content":"\r\n# Configuration\r\n\r\nMyriad uses a configuration file called `myriad.toml` which uses the [toml format](https://toml.io/en/).  Myriad looks in the current directory fro this file but it can be configured by placing `MyriadConfigFile` in your project file like this:\r\n\r\n```msbuild\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<Project Sdk=\"Microsoft.NET.Sdk\">\r\n  <PropertyGroup>\r\n    <TargetFramework>net5.0</TargetFramework>\r\n    <OutputType>Exe</OutputType>\r\n    <MyriadConfigFile>myConfig.toml</MyriadConfigFile>\r\n  </PropertyGroup>\r\n...\r\n```\r\n\r\nThe configuration section for the built in plugins is very simple, the configuration name or key is passed in by either the plugins generator attribute, in the case of the fields plugin:\r\n\r\n```\r\n[<Generator.Fields \"fields\">]\r\ntype Test1 = { one: int; two: string; three: float; four: float32 }\r\n\r\n```\r\n\r\nThe configuration key is \"fields\", if we now look at the `myriad.toml` file it looks like this:\r\n\r\n```toml\r\n[fields]\r\nnamespace = \"TestFields\"\r\n```\r\n\r\nYou can see that there is a `namespace` key that is set to \"TestFields\".  Using an attribute like this you can configure your plugin to take further information on how to generate the code.  \r\n\r\nThere is another mechanism of specifying what configuration a plugin will use and that is by using an MSBuild property `MyriadConfigKey` as follows:\r\n\r\n```xml\r\n<Compile Include=\"ArbitaryFile.fs\">\r\n    <MyriadFile>Test.txt</MyriadFile>\r\n    <MyriadConfigKey>example1</MyriadConfigKey>\r\n</Compile>\r\n```\r\n\r\nThe configuration key `example1` would be passed to the plugin so that it could be consumed.  This is used in the `Myriad.Plugin.Example1` plugin and use uses configuration to specify the `namespace` used.  \r\n\r\n# Writing plugins to consume configuration\r\n\r\nThe plugin interface receives this key via: `GeneratorContext` . `ConfigKey`:\r\n\r\n```fsharp\r\ntype GeneratorContext = {\r\n    ConfigKey: string option\r\n    ConfigGetter: string -> (string * obj) seq\r\n    InputFileName: string\r\n}\r\n\r\ntype IMyriadGenerator =\r\n    abstract member ValidInputExtensions: string seq\r\n    abstract member Generate: GeneratorContext -> FsAst.AstRcd.SynModuleOrNamespaceRcd list\r\n```\r\n\r\nValidInputExtensions is used so a plugin is tied to certain file types as input, if you plugin generating ast fragments from java files then you would add `.java` to the `ValidInputExtensions` implementation for example.  \r\n\r\n```fsharp\r\n    interface IMyriadGenerator with\r\n        member __.ValidInputExtensions = seq {\".java\"}\r\n        //...\r\n```\r\n\r\nWhile we are discussing the `IMyriadGenerator` interface lets discuss the `Generate` member:\r\n\r\nGenerate takes a `GeneratorContext` which contains the `ConfigKey` as mentioned above, the `ConfigGetter` : `string -> (string * obj) seq` which is a mean to allow access to the `myriad.toml` file, you give the function the configuration ket you wish to receive and it returns the configuration.  Finally a `InputFileName` is also passed in so you can load or parse your input files ready to generate an AST.  If you look at the included plugins you can see the mechanism for extracting and building AST fragments for reference.  \r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/debugging.html","title":"Debugging","content":"\r\n# Debugging\r\n\r\nTo debug Myriad, you can use the following two command line options:\r\n\r\n* `--verbose` — write diagnostic logs out to standard out\r\n* `--wait-for-debugger` — causes Myriad to wait for a debugger to attach to the Myriad process\r\n\r\nThese can be triggered from msbuild by the `<MyriadSdkVerboseOutput>true</MyriadSdkVerboseOutput>` and `<MyriadSdkWaitForDebugger>true</MyriadSdkWaitForDebugger>` properties, respectively."},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/external-plugins.html","title":"External Plugins","content":"\r\n# Using external plugins\r\n\r\nTo consume external plugins that aren't included in the `Myriad.Plugins` package, you must register them with Myriad. If you are using the CLI tool then the way to do this is by passing in the `--plugin <path to dll>` command-line argument. If you are using MSBuild then this can be done by adding to the `MyriadSdkGenerator` property to your project file:\r\n\r\n```xml\r\n<ItemGroup>\r\n    <MyriadSdkGenerator Include=\"<path to plugin dll>\" />\r\n</ItemGroup>\r\n```\r\n\r\nFor example, if you had a project layout like this:\r\n\r\n```\r\n\\src\r\n-\\GeneratorLib\r\n - Generator.fs\r\n - Generator.fsproj\r\n-\\GeneratorTests\r\n - Tests.fs\r\n - GeneratorTests.fsproj\r\n```\r\n\r\nYou would add the following to Generator.fsproj:\r\n```xml\r\n  <ItemGroup>\r\n    <Content Include=\"build\\Generator.props\">\r\n      <Pack>true</Pack>\r\n      <PackagePath>%(Identity)</PackagePath>\r\n      <Visible>true</Visible>\r\n    </Content>\r\n  </ItemGroup>\r\n```\r\n\r\nThen add a new folder `build` with the `Generator.props` file within:\r\n```xml\r\n<Project>\r\n    <ItemGroup>\r\n        <MyriadSdkGenerator Include=\"$(MSBuildThisFileDirectory)/../lib/netstandard2.1/Generator.dll\" />\r\n    </ItemGroup>\r\n</Project>\r\n```\r\n\r\nOften an additional props file (In this smaple the file would be `Generator.InTest.props`) is used to make testing easier.  The matching element for the tests fsproj would be something like this:\r\n\r\n```xml\r\n<Project>\r\n    <ItemGroup>\r\n        <MyriadSdkGenerator Include=\"$(MSBuildThisFileDirectory)/../bin/$(Configuration)/netstandard2.1/Generator.dll\" />\r\n    </ItemGroup>\r\n</Project>\r\n```\r\n\r\nNotice the Include path is pointing locally rather than within the packaged nuget folder structure.\r\n\r\nIn your testing `fsproj` you would add the following to allow the plugin to be used locally rather that having to consume a nuget package:\r\n\r\n```xml\r\n<!-- include plugin -->\r\n<Import Project=\"<Path to Generator plugin location>\\build\\Myriad.Plugins.InTest.props\" />\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//tutorials/msbuild-usage.html","title":"MSBuild usage","content":"\r\n# MSBuild usage\r\n\r\nPlugins for Myriad are supplied by simply including the nuget package in your project, the nuget infrastructure supplies the necessary MSBuild props and targets so that the plugin is used by Myriad automatically. Following the source for the fields plugin can be used as reference until more details about authoring plugins is created.\r\n\r\nTo use Myriad via its MSBuild support you add the `Myriad.Core` and `Myriad.Sdk` package references:\r\n```xml\r\n    <ItemGroup>\r\n      <PackageReference Include=\"Myriad.Core\" Version=\"0.5.1\" />\r\n      <PackageReference Include=\"Myriad.Sdk\" Version=\"0.5.1\" />\r\n      <PackageReference Include=\"Myriad.Plugins\" Version=\"0.5.1\" /> <!-- Built in set of plugins -->\r\n    </ItemGroup>\r\n```\r\n\r\nAn input file is specified by using the usual `Compile` element:\r\n```xml\r\n<Compile Include=\"Generated.fs\">\r\n    <MyriadFile>Library.fs</MyriadFile>\r\n</Compile>\r\n```\r\n\r\nThis is configuring Myriad so that a file called `Generated.fs` will be included in the build using `Library.fs` as input.  \r\n\r\nMyriad works by using plugins to generate code.  A plugin called fields is included with Myriad which takes inspiration from OCamls [ppx_fields_conv](https://github.com/janestreet/ppx_fields_conv) plugin of the same name.  There are also plugins included to generate discriminated union helpers adn record lenses.\r\n"},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/index.html","title":"Myriad.Plugins - API Reference","content":"Myriad.Plugins \n Myriad.Plugins"},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/myriad-plugins-generator.html","title":"Generator","content":"Generator \n  \n  \n DuCasesAttribute  FieldsAttribute  LensesAttribute <p>Instructs to generate lenses for each property of the record</p>\r\n\r\n \n getConfigFromAttribute  \n "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/myriad-plugins-ducasesgenerator.html","title":"DUCasesGenerator","content":"DUCasesGenerator \n  \n ( .ctor ) "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/myriad-plugins-fieldsgenerator.html","title":"FieldsGenerator","content":"FieldsGenerator \n  \n ( .ctor ) "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/myriad-plugins-lensesgenerator.html","title":"LensesGenerator","content":"LensesGenerator \n  \n ( .ctor ) "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/myriad-plugins-generator-ducasesattribute.html","title":"DuCasesAttribute","content":"DuCasesAttribute \n  \n ( .ctor ) "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/myriad-plugins-generator-fieldsattribute.html","title":"FieldsAttribute","content":"FieldsAttribute \n  \n ( .ctor ) "},{"uri":"https://moiraesoftware.github.io/myriad//reference/Myriad.Plugins/myriad-plugins-generator-lensesattribute.html","title":"LensesAttribute","content":"LensesAttribute \n <p>Instructs to generate lenses for each property of the record</p>\r\n\r\n \n ( .ctor )  ( .ctor )  ( .ctor )  config  wrapperName "}]